import pandas as pdimport csvBLACK = TrueRED = Falseclass TreeNode:    def __init__(self, key):        self._key = key    @property    def key(self):        return self._key    @key.setter    def key(self, value):        self._key = valueclass RedBlackTreeNode(TreeNode):    def __init__(self, key, color=RED):        super().__init__(key)        self._color = color        self._parent = None        self._left = None        self._right = None    @property    def color(self):        return self._color    @color.setter    def color(self, value):        self._color = value    @property    def parent(self):        return self._parent    @parent.setter    def parent(self, value):        self._parent = value    @property    def left(self):        return self._left    @left.setter    def left(self, value):        self._left = value    @property    def right(self):        return self._right    @right.setter    def right(self, value):        self._right = valueclass RedBlackTree:    def __init__(self):        self._NIL = RedBlackTreeNode(None, BLACK)        self._NIL.left = self._NIL.right = self._NIL.parent = self._NIL        self._root = self._NIL    def search(self, key):        current = self._root        while current != self._NIL and current.key != key:            if key < current.key:                current = current.left            else:                current = current.right        return current    def minimum(self, node):        while node.left != self._NIL:            node = node.left        return node    def transplant(self, u, v):        if u.parent == self._NIL:            self._root = v        elif u == u.parent.left:            u.parent.left = v        else:            u.parent.right = v        v.parent = u.parent    def left_rotate(self, x):        y = x.right        x.right = y.left        if y.left != self._NIL:            y.left.parent = x        y.parent = x.parent        if x.parent == self._NIL:            self._root = y        elif x == x.parent.left:            x.parent.left = y        else:            x.parent.right = y        y.left = x        x.parent = y    def right_rotate(self, x):        y = x.left        x.left = y.right        if y.right != self._NIL:            y.right.parent = x        y.parent = x.parent        if x.parent == self._NIL:            self._root = y        elif x == x.parent.right:            x.parent.right = y        else:            x.parent.left = y        y.right = x        x.parent = y    def insert(self, key):        new_node = RedBlackTreeNode(key)        new_node.left = self._NIL        new_node.right = self._NIL        parent = self._NIL        current = self._root        while current != self._NIL:            parent = current            if new_node.key < current.key:                current = current.left            else:                current = current.right        new_node.parent = parent        if parent == self._NIL:            self._root = new_node        elif new_node.key < parent.key:            parent.left = new_node        else:            parent.right = new_node        new_node.color = RED        self.insert_fixup(new_node)    def insert_fixup(self, z):        while z.parent.color == RED:            if z.parent == z.parent.parent.left:                y = z.parent.parent.right                if y.color == RED:                    z.parent.color = BLACK                    y.color = BLACK                    z.parent.parent.color = RED                    z = z.parent.parent                else:                    if z == z.parent.right:                        z = z.parent                        self.left_rotate(z)                    z.parent.color = BLACK                    z.parent.parent.color = RED                    self.right_rotate(z.parent.parent)            else:                y = z.parent.parent.left                if y.color == RED:                    z.parent.color = BLACK                    y.color = BLACK                    z.parent.parent.color = RED                    z = z.parent.parent                else:                    if z == z.parent.left:                        z = z.parent                        self.right_rotate(z)                    z.parent.color = BLACK                    z.parent.parent.color = RED                    self.left_rotate(z.parent.parent)        self._root.color = BLACK    def delete(self, key):        z = self.search(key)        if z == self._NIL:            return        y = z        y_original_color = y.color        if z.left == self._NIL:            x = z.right            self.transplant(z, z.right)        elif z.right == self._NIL:            x = z.left            self.transplant(z, z.left)        else:            y = self.minimum(z.right)            y_original_color = y.color            x = y.right            if y.parent == z:                x.parent = y            else:                self.transplant(y, y.right)                y.right = z.right                y.right.parent = y            self.transplant(z, y)            y.left = z.left            y.left.parent = y            y.color = z.color        if y_original_color == BLACK:            self.delete_fixup(x)    def delete_fixup(self, x):        while x != self._root and x.color == BLACK:            if x == x.parent.left:                w = x.parent.right                if w.color == RED:                    w.color = BLACK                    x.parent.color = RED                    self.left_rotate(x.parent)                    w = x.parent.right                if w.left.color == BLACK and w.right.color == BLACK:                    w.color = RED                    x = x.parent                else:                    if w.right.color == BLACK:                        w.left.color = BLACK                        w.color = RED                        self.right_rotate(w)                        w = x.parent.right                    w.color = x.parent.color                    x.parent.color = BLACK                    w.right.color = BLACK                    self.left_rotate(x.parent)                    x = self._root            else:                w = x.parent.left                if w.color == RED:                    w.color = BLACK                    x.parent.color = RED                    self.right_rotate(x.parent)                    w = x.parent.left                if w.right.color == BLACK and w.left.color == BLACK:                    w.color = RED                    x = x.parent                else:                    if w.left.color == BLACK:                        w.right.color = BLACK                        w.color = RED                        self.left_rotate(w)                        w = x.parent.left                    w.color = x.parent.color                    x.parent.color = BLACK                    w.left.color = BLACK                    self.right_rotate(x.parent)                    x = self._root        x.color = BLACK    def inorder_traversal(self, node):        stack = []        current = node        while stack or current != self._NIL:            while current != self._NIL:                stack.append(current)                current = current.left            current = stack.pop()            print(current.key, end=" ")            current = current.right    def print_tree(self):        print("Inorder Traversal:", end=" ")        self.inorder_traversal(self._root)        print()    def print_tree_structure(self):        levels = self.get_tree_levels(self._root)        for level in levels:            print(" ".join(level))    def get_tree_levels(self, root):        if root == self._NIL:            return []        result = []        current_level = [root]        while current_level:            level_keys = []            next_level = []            for node in current_level:                if node == self._NIL:                    level_keys.append("NIL")                else:                    level_keys.append(f"{node.key}{'R' if node.color == RED else 'B'}")                    next_level.append(node.left if node.left else self._NIL)                    next_level.append(node.right if node.right else self._NIL)            result.append(level_keys)            current_level = [node for node in next_level if node != self._NIL]        return result    def insert_from_csv(self, filename):        with open(filename, mode='r', encoding='utf-8') as file:            csv_reader = csv.DictReader(file)            for row in csv_reader:                roll_number = row['RollNumber']                numeric_part = int(roll_number[2:])                self.insert(numeric_part)class DataProcessor:    def __init__(self, file_path):        self._file_path = file_path    def process_data(self):        try:            dtype_spec = {                'ISBN': str,                'Book-Title': str,                'Book-Author': str,                'Year-Of-Publication': str,                'Publisher': str,                'Image-URL-S': str,                'Image-URL-M': str,                'Image-URL-L': str            }            df = pd.read_csv(self._file_path, on_bad_lines='skip', dtype=dtype_spec, low_memory=False, nrows=50)            # expand= False: trả về dưới dạng một Series            df['ISBN_Fill'] = df["ISBN"].str.extract(r'(\d+)', expand=False)            df_fillter = df.dropna(subset=['ISBN_Fill'])            # inplace = True: DataFrame được sửa đổi trực tiếp và phương thức trả về            df_fillter.set_index('ISBN_Fill', inplace=True)            # orient='index' : biến đổi DataFrame thành từ điển theo chiều ngang            data_dict = df_fillter.to_dict(orient='index')            print("Data has been stored successfully")            return data_dict.keys()        except Exception as e:            print(f"Error reading the file: {e}")            return Nonefile_path = "E:\\FPT University\\2024\\SUM_24\\CSD203\\Sourcode\\asignement\\data.csv"dp = DataProcessor(file_path)data = dp.process_data()tree = RedBlackTree()tree.insert(data)tree.print_tree()